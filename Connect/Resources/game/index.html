<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Connections</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@500;700&display=swap" rel="stylesheet" />
  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      background: linear-gradient(135deg, #081d36 0%, #0e2642 55%, #132c52 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-font-smoothing: antialiased;
      font-family: "Baloo 2", -apple-system, system-ui, "Segoe UI", Roboto, sans-serif;
      color: #2b0b4b;
    }
    #root {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: linear-gradient(135deg, #0e2a47 0%, #1b2f66 100%);
      border-radius: 28px;
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.55), 0 0 0 3px rgba(22, 48, 86, 0.8);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script>
    (function () {
      if (window.React && window.ReactDOM) {
        return;
      }

      const hooks = [];
      let rootElement = null;
      let rootContainer = null;
      let renderScheduled = false;
      let hookCursor = 0;
      let pendingEffects = [];

      const isEventProp = (name) => /^on[A-Z]/.test(name);
      const toEventName = (name) => name.slice(2).toLowerCase();

      const depsChanged = (next, prev) => {
        if (!prev) return true;
        if (!next) return true;
        if (next.length !== prev.length) return true;
        for (let i = 0; i < next.length; i++) {
          if (!Object.is(next[i], prev[i])) return true;
        }
        return false;
      };

      const scheduleRender = () => {
        if (renderScheduled) return;
        renderScheduled = true;
        Promise.resolve().then(() => {
          renderScheduled = false;
          performRender();
        });
      };

      const createElement = (type, props, ...children) => {
        const flat = [];
        const pushChild = (child) => {
          if (Array.isArray(child)) {
            child.forEach(pushChild);
          } else if (child === null || child === false || child === true) {
            // ignore
          } else {
            flat.push(child);
          }
        };
        children.forEach(pushChild);
        return { type, props: props || {}, children: flat };
      };

      const createDom = (vnode) => {
        if (vnode === null || vnode === false || vnode === true) {
          return document.createDocumentFragment();
        }
        if (typeof vnode === "string" || typeof vnode === "number") {
          return document.createTextNode(String(vnode));
        }
        if (Array.isArray(vnode)) {
          const frag = document.createDocumentFragment();
          vnode.forEach((child) => {
            const dom = createDom(child);
            if (dom) frag.appendChild(dom);
          });
          return frag;
        }
        if (typeof vnode.type === "function") {
          const rendered = vnode.type({ ...(vnode.props || {}), children: vnode.children });
          return createDom(rendered);
        }
        const dom = document.createElement(vnode.type);
        const props = vnode.props || {};
        for (const name in props) {
          if (name === "style" && props.style && typeof props.style === "object") {
            const style = props.style;
            for (const key in style) {
              if (style[key] != null) {
                dom.style[key] = style[key];
              }
            }
          } else if (name === "ref" && props.ref) {
            const ref = props.ref;
            if (typeof ref === "function") {
              ref(dom);
            } else if (typeof ref === "object") {
              ref.current = dom;
            }
          } else if (name === "dangerouslySetInnerHTML" && props.dangerouslySetInnerHTML) {
            dom.innerHTML = props.dangerouslySetInnerHTML.__html || "";
          } else if (name === "className") {
            dom.setAttribute("class", props[name]);
          } else if (isEventProp(name) && typeof props[name] === "function") {
            dom.addEventListener(toEventName(name), props[name]);
          } else if (name !== "children" && props[name] != null) {
            dom.setAttribute(name, props[name]);
          }
        }
        vnode.children.forEach((child) => {
          const domChild = createDom(child);
          if (domChild) dom.appendChild(domChild);
        });
        return dom;
      };

      const performRender = () => {
        if (!rootElement || !rootContainer) return;
        hookCursor = 0;
        pendingEffects = [];
        const tree = renderElement(rootElement);
        rootContainer.innerHTML = "";
        const dom = createDom(tree);
        if (dom) rootContainer.appendChild(dom);
        const effects = pendingEffects.slice();
        pendingEffects.length = 0;
        effects.forEach((run) => run());
      };

      const renderElement = (element) => {
        if (typeof element.type === "function") {
          return element.type({ ...(element.props || {}), children: element.children });
        }
        return element;
      };

      const useState = (initialValue) => {
        const index = hookCursor++;
        if (!hooks[index] || hooks[index].kind !== "state") {
          const value = typeof initialValue === "function" ? initialValue() : initialValue;
          hooks[index] = { kind: "state", value };
        }
        const setState = (nextValue) => {
          const hook = hooks[index];
          const next = typeof nextValue === "function" ? nextValue(hook.value) : nextValue;
          if (!Object.is(next, hook.value)) {
            hook.value = next;
            scheduleRender();
          }
        };
        hooks[index].setState = setState;
        return [hooks[index].value, setState];
      };

      const useRef = (initialValue) => {
        const index = hookCursor++;
        if (!hooks[index] || hooks[index].kind !== "ref") {
          hooks[index] = { kind: "ref", value: { current: initialValue } };
        }
        return hooks[index].value;
      };

      const useMemo = (factory, deps) => {
        const index = hookCursor++;
        const hook = hooks[index];
        if (!hook || hook.kind !== "memo" || depsChanged(deps, hook.deps)) {
          const value = factory();
          hooks[index] = { kind: "memo", value, deps };
          return value;
        }
        return hook.value;
      };

      const useCallback = (fn, deps) => useMemo(() => fn, deps);

      const useEffect = (effect, deps) => {
        const index = hookCursor++;
        const hook = hooks[index];
        const shouldRun = !hook || hook.kind !== "effect" || depsChanged(deps, hook.deps);
        if (!hook || hook.kind !== "effect") {
          hooks[index] = { kind: "effect", deps, cleanup: null };
        } else {
          hooks[index].deps = deps;
        }
        if (shouldRun) {
          const previous = hook && hook.kind === "effect" ? hook.cleanup : null;
          pendingEffects.push(() => {
            if (typeof previous === "function") {
              try { previous(); } catch (err) { console.error(err); }
            }
            const cleanup = effect();
            hooks[index].cleanup = typeof cleanup === "function" ? cleanup : null;
          });
        }
      };

      const React = { createElement, useState, useEffect, useMemo, useRef, useCallback };
      const ReactDOM = {
        createRoot(container) {
          return {
            render(element) {
              rootElement = element;
              rootContainer = container;
              performRender();
            },
          };
        },
        render(element, container) {
          this.createRoot(container).render(element);
        },
      };

      window.React = React;
      window.ReactDOM = ReactDOM;
    })();
  </script>

  <script>

// === BEGIN: your working React component (single-file) ===
// Paste the whole file you currently have open in canvas, exactly as-is.
// Then add two tiny hooks:
//  1) call window.webkit.messageHandlers.hud?.postMessage({score,best,moves})
//     whenever these values change,
//  2) expose window.GameAPI.newGame = () => newGame() to allow native button to trigger reset.


/* ---------------- PASTE BELOW THIS LINE ---------------- */

;(function () {
  if (typeof window === "undefined") return;
  if (!window.React || !window.ReactDOM) {
    const fallback = document.getElementById("root");
    if (fallback) {
      fallback.innerHTML = '<div style="color:#fff;padding:24px;text-align:center">Unable to load game. Please check your connection and try again.</div>';
    }
    console.error("Match3: React or ReactDOM is unavailable");
    return;
  }

  const React = window.React;
  const ReactDOM = window.ReactDOM;
  const { useEffect, useMemo, useRef, useState, useCallback } = React;

  let GLOBAL_ID = 1;
  const nextId = () => GLOBAL_ID++;
  const cloneCell = (cell) => ({ ...cell, keys: { ...cell.keys } });

  const getHudHandler = () => {
    if (typeof window === "undefined") return null;
    const wk = window.webkit;
    if (!wk || !wk.messageHandlers) return null;
    const handler = wk.messageHandlers.hud;
    if (!handler || typeof handler.postMessage !== "function") return null;
    return handler;
  };

  const postHudMessage = (payload) => {
    try {
      const handler = getHudHandler();
      if (handler) {
        handler.postMessage(payload);
      }
    } catch (err) {
      console.error("Error sending HUD update:", err);
    }
  };

  // Match‑3 Canvas Game – React single‑file (Plain JS, no TypeScript)
  // Features:
  // - Stripes (row/col) on 4‑matches; Bombs (3×3) on 5+
  // - Cascades: gravity + refill until stable
  // - Auto‑shuffle when stuck (no valid moves)
  // - Levels with layout masks (blocked cells) — Checker level removed per request
  // - Color‑blind safe palette (Okabe‑Ito)
  // - Move limit: 25
  // - **Keyed connections**: tiles connect only if facing-side keys align; matches can bend (L/zig‑zag)
  // - Idle hint: after 10s, highlight a valid swap
  // - Internal tests to prevent regressions

  // ---------------- Types (JS comments) ----------------
  // SideKeys = { u:boolean, r:boolean, d:boolean, l:boolean }
  // Special  = "none" | "stripeH" | "stripeV" | "bomb"
  // Cell     = { type:number, id:number, special:Special, keys:SideKeys }
  // RC       = { r:number, c:number }
  // Group    = { dir:"row"|"col", cells:RC[] }
  // Level    = { name:string, size:number, mask:(r,c)=>boolean }

  function Match3CanvasGame() {
  // --- Tunables ---
  const TILE = 48; // px per tile (reduced from 56 to fit better)
  const PADDING = 16; // canvas padding
  const HUD_HEIGHT = 88; // dedicated top strip for the HUD
  const BOARD_TOP = PADDING + HUD_HEIGHT;
  const TYPES = 6; // base tile kinds
  const DEFAULT_MOVES = 25;
  const BLOCK = -2; // blocked/impassable cell marker

  // Levels: mask(r,c) => playable?
  const LEVELS = [
    { name: "Classic", size: 8, mask: () => true },
    {
      name: "Donut",
      size: 9,
      mask: (r, c) => {
        const n = 9;
        const edge = r === 0 || c === 0 || r === n - 1 || c === n - 1;
        const inner = r >= 2 && r <= n - 3 && c >= 2 && c <= n - 3;
        return !edge && !(inner && (r === 4 || c === 4));
      },
    },
    { name: "Plus", size: 8, mask: (r, c) => r === 3 || r === 4 || c === 3 || c === 4 },
  ];

  const [levelIndex, setLevelIndex] = useState(0);
  const level = LEVELS[levelIndex];
  const [size, setSize] = useState(level.size);
  const [moves, setMoves] = useState(DEFAULT_MOVES);
  const [score, setScore] = useState(0);
  const [best, setBest] = useState(0);
  const [board, setBoard] = useState(() => makeFreshBoard(level, TYPES, BLOCK));
  const boardRef = useRef(board);
  const [selected, setSelected] = useState(null);
  const [busy, setBusy] = useState(false);
  const [justShuffled, setJustShuffled] = useState(false);
  const canvasRef = useRef(null);
  const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
  const lastSwapRef = useRef(null);
  const [lastActionAt, setLastActionAt] = useState(() => Date.now());
  const [hintCells, setHintCells] = useState(null);
  // tiny animation clock for playful pulses
  const [tick, setTick] = useState(0);
  const animationsRef = useRef({ swap: null, clears: [], falls: [], spawns: [] });
  const busyRef = useRef(busy);
  const inputModeRef = useRef(null);
  useEffect(() => {
    boardRef.current = board;
  }, [board]);
  useEffect(() => {
    busyRef.current = busy;
  }, [busy]);
  const commitBoard = useCallback((next) => {
    boardRef.current = next;
    setBoard(next);
  }, []);
  const setBusyState = useCallback((value) => {
    busyRef.current = value;
    setBusy(value);
  }, []);
  const timeNow = () => (typeof performance !== "undefined" && performance.now ? performance.now() : Date.now());
  useEffect(() => {
    let raf;
    const loop = () => { setTick((t) => (t + 1) % 6000); raf = requestAnimationFrame(loop); };
    raf = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(raf);
  }, []);

  // WebAudio minimal beeps
  const audioCtxRef = useRef(null);
  const ensureAudio = () => {
    if (!audioCtxRef.current) {
      const Ctx = (window && (window.AudioContext || window.webkitAudioContext));
      if (Ctx) audioCtxRef.current = new Ctx();
    }
  };
  const playSound = (notes) => {
    if (!notes || notes.length === 0) return;
    ensureAudio();
    const ctx = audioCtxRef.current;
    if (!ctx) return;
    const base = ctx.currentTime;
    notes.forEach(({ freq, start = 0, dur = 0.18, gain = 0.045, type = "sine" }) => {
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, base + start);
      const attack = Math.max(0.005, Math.min(0.03, dur * 0.2));
      g.gain.setValueAtTime(0.0001, base + start);
      g.gain.exponentialRampToValueAtTime(gain, base + start + attack);
      g.gain.exponentialRampToValueAtTime(0.0001, base + start + dur);
      osc.connect(g);
      g.connect(ctx.destination);
      osc.start(base + start);
      osc.stop(base + start + dur + 0.02);
    });
  };

  const playSelect = () => playSound([
    { freq: 540, dur: 0.14, gain: 0.03, type: "triangle" },
    { freq: 810, start: 0.02, dur: 0.12, gain: 0.02, type: "sine" }
  ]);

  const playSwap = () => playSound([
    { freq: 360, dur: 0.16, gain: 0.035, type: "triangle" },
    { freq: 520, start: 0.04, dur: 0.18, gain: 0.03, type: "sine" }
  ]);

  const playInvalid = () => playSound([
    { freq: 180, dur: 0.2, gain: 0.04, type: "sawtooth" },
    { freq: 120, start: 0.08, dur: 0.18, gain: 0.03, type: "sine" }
  ]);

  const playMatch = (chain = 1) => {
    const base = 620 + chain * 60;
    playSound([
      { freq: base, dur: 0.22, gain: 0.04, type: "triangle" },
      { freq: base * 1.32, start: 0.04, dur: 0.18, gain: 0.03, type: "sine" },
      { freq: base / 2, start: 0.02, dur: 0.3, gain: 0.025, type: "square" }
    ]);
  };

  const playCascade = () => playSound([
    { freq: 420, dur: 0.24, gain: 0.032, type: "triangle" },
    { freq: 560, start: 0.05, dur: 0.2, gain: 0.028, type: "sine" }
  ]);

  const playSpawn = () => playSound([
    { freq: 880, dur: 0.18, gain: 0.028, type: "sine" },
    { freq: 1320, start: 0.03, dur: 0.16, gain: 0.02, type: "triangle" }
  ]);

  const playShuffle = () => playSound([
    { freq: 260, dur: 0.22, gain: 0.04, type: "sine" },
    { freq: 400, start: 0.05, dur: 0.24, gain: 0.035, type: "triangle" }
  ]);

  // Canvas sizing
  const logicalWidth = useMemo(() => PADDING * 2 + size * TILE, [size]);
  const logicalHeight = logicalWidth + HUD_HEIGHT;

  function newGame(newLevelIndex = levelIndex) {
    const lvl = LEVELS[newLevelIndex];
    setLevelIndex(newLevelIndex);
    setSize(lvl.size);
    const fresh = makeFreshBoard(lvl, TYPES, BLOCK);
    if (!isValidBoard(fresh, lvl.size)) {
      console.error("Init produced invalid board; falling back to classic 8x8.");
      const fallback = makeFreshBoard(LEVELS[0], TYPES, BLOCK);
      commitBoard(fallback);
    } else {
      commitBoard(fresh);
    }
    setMoves(DEFAULT_MOVES);
    setScore(0);
    setBest(0);
    setSelected(null);
    setBusyState(false);
    setJustShuffled(false);
    setHintCells(null);
    setLastActionAt(Date.now());
    // Send HUD update to Swift
    postHudMessage({ score: 0, best: 0, moves: DEFAULT_MOVES });
  }

  // Drawing
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const width = logicalWidth;
    const height = logicalHeight;
    canvas.width = Math.floor(width * dpr);
    canvas.height = Math.floor(height * dpr);
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const now = timeNow();
    const activeClears = [];
    animationsRef.current.clears = animationsRef.current.clears.filter((anim) => {
      const elapsed = now - anim.start;
      if (elapsed < anim.duration) {
        activeClears.push({ ...anim, elapsed, progress: Math.min(1, elapsed / anim.duration) });
        return true;
      }
      return false;
    });

    const fallMap = new Map();
    animationsRef.current.falls = animationsRef.current.falls.filter((anim) => {
      const elapsed = now - anim.start;
      if (elapsed < anim.duration) {
        const progress = Math.min(1, elapsed / anim.duration);
        anim.items.forEach((item) => {
          fallMap.set(key(item.to.r, item.to.c), { progress, item });
        });
        return true;
      }
      return false;
    });

    const spawnMap = new Map();
    animationsRef.current.spawns = animationsRef.current.spawns.filter((anim) => {
      const elapsed = now - anim.start;
      if (elapsed < anim.duration) {
        const progress = Math.min(1, elapsed / anim.duration);
        anim.cells.forEach((cell) => {
          spawnMap.set(key(cell.r, cell.c), { progress });
        });
        return true;
      }
      return false;
    });

    let swapAnim = animationsRef.current.swap;
    if (swapAnim) {
      const elapsed = now - swapAnim.start;
      if (elapsed >= swapAnim.total) {
        swapAnim = null;
        animationsRef.current.swap = null;
      } else {
        swapAnim = { ...swapAnim, elapsed };
      }
    }

    const skipCoords = new Set();
    if (swapAnim) {
      swapAnim.tiles.forEach((tile) => {
        skipCoords.add(key(tile.from.r, tile.from.c));
        skipCoords.add(key(tile.to.r, tile.to.c));
      });
    }

    // background – mirror the host app gradient for cohesion
    const bg = ctx.createLinearGradient(0, 0, width, height);
    bg.addColorStop(0, "#081d36");
    bg.addColorStop(0.55, "#0e2642");
    bg.addColorStop(1, "#132c52");
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, width, height);

    // board frame that keeps the playfield dark and cohesive with the app shell
    ctx.save();
    ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
    ctx.shadowBlur = 28;
    ctx.shadowOffsetY = 20;
    const frameX = PADDING - 10;
    const frameY = BOARD_TOP - 10;
    const frameW = size * TILE + 20;
    const frameH = size * TILE + 20;
    roundRect(ctx, frameX, frameY, frameW, frameH, 28);
    const frameFill = ctx.createLinearGradient(frameX, frameY, frameX, frameY + frameH);
    frameFill.addColorStop(0, "#0a1d33");
    frameFill.addColorStop(1, "#020914");
    ctx.fillStyle = frameFill;
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    const innerX = PADDING;
    const innerY = BOARD_TOP;
    const innerW = size * TILE;
    const innerH = size * TILE;
    roundRect(ctx, innerX, innerY, innerW, innerH, 22);
    const playfield = ctx.createLinearGradient(innerX, innerY, innerX, innerY + innerH);
    playfield.addColorStop(0, "#0e2a47");
    playfield.addColorStop(1, "#0b2038");
    ctx.fillStyle = playfield;
    ctx.fill();
    const bubbleCount = 5;
    for (let i = 0; i < bubbleCount; i++) {
      const offset = (tick + i * 240) % 1200;
      const phase = offset / 1200;
      const bx = innerX + innerW * (0.15 + 0.7 * ((i % 2 === 0 ? phase : 1 - phase)));
      const by = innerY + innerH * (0.2 + 0.6 * Math.sin((tick / 40 + i) % (Math.PI * 2)) * 0.5 + 0.3 * (i / bubbleCount));
      const radius = 22 + 12 * Math.sin((tick / 30 + i) % (Math.PI * 2));
      const gradient = ctx.createRadialGradient(bx, by, 0, bx, by, radius);
      gradient.addColorStop(0, "rgba(88, 182, 255, 0.18)");
      gradient.addColorStop(0.6, "rgba(36, 124, 210, 0.08)");
      gradient.addColorStop(1, "rgba(10, 40, 80, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(bx, by, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(32, 86, 140, 0.55)";
    roundRect(ctx, innerX + 2, innerY + 2, innerW - 4, innerH - 4, 20);
    ctx.stroke();
    ctx.restore();

    // HUD
    drawHUD(ctx, score, moves, best, width, HUD_HEIGHT, PADDING);

    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
    const easeOutBack = (t) => {
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
    };

    // tiles
    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const cell = board[r] && board[r][c];
        const x = PADDING + c * TILE;
        const y = BOARD_TOP + r * TILE;
        if (!cell) continue;
        const coordKey = key(r, c);
        if (skipCoords.has(coordKey)) continue;

        const fall = fallMap.get(coordKey);
        if (fall) {
          const startY = BOARD_TOP + fall.item.from.r * TILE;
          const endY = BOARD_TOP + fall.item.to.r * TILE;
          const eased = easeOutCubic(fall.progress);
          const curY = startY + (endY - startY) * eased;
          drawTile(ctx, x, curY, TILE, cell, BLOCK);
          continue;
        }

        const spawn = spawnMap.get(coordKey);
        if (spawn) {
          const scale = 0.6 + 0.4 * easeOutBack(spawn.progress);
          ctx.save();
          ctx.translate(x + TILE / 2, y + TILE / 2);
          ctx.scale(scale, scale);
          ctx.translate(-(x + TILE / 2), -(y + TILE / 2));
          drawTile(ctx, x, y, TILE, cell, BLOCK);
          ctx.restore();
        } else {
          const floatPhase = Math.sin((tick + (r * 37 + c * 19)) * 0.02) * 0.6;
          drawTile(ctx, x, y + floatPhase, TILE, cell, BLOCK);
        }

        if (selected && selected.r === r && selected.c === c && cell.type >= 0) {
          const phase = (tick % 60) / 60;
          const pulse = 0.35 + 0.25 * Math.sin(phase * Math.PI * 2);
          ctx.save();
          ctx.shadowColor = `rgba(255,255,255,${pulse})`;
          ctx.shadowBlur = 18;
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2.5;
          roundRect(ctx, x + 3, y + 3, TILE - 6, TILE - 6, 14);
          ctx.stroke();
          ctx.restore();
        }
      }
    }

    if (swapAnim) {
      const { duration, elapsed, bounce, tiles } = swapAnim;
      const progress = Math.min(1, elapsed / duration);
      const eased = bounce
        ? easeOutCubic(progress <= 1 ? progress : 2 - progress)
        : easeOutCubic(progress);
      tiles.forEach((tile, index) => {
        const fromX = PADDING + tile.from.c * TILE;
        const fromY = BOARD_TOP + tile.from.r * TILE;
        const toX = PADDING + tile.to.c * TILE;
        const toY = BOARD_TOP + tile.to.r * TILE;
        let ratio;
        if (bounce) {
          const t = Math.min(1, elapsed / duration);
          ratio = elapsed <= duration ? easeOutCubic(t) : easeOutCubic(1 - (elapsed - duration) / duration);
        } else {
          ratio = eased;
        }
        const curX = fromX + (toX - fromX) * ratio;
        const curY = fromY + (toY - fromY) * ratio;
        ctx.save();
        ctx.translate(curX + TILE / 2, curY + TILE / 2);
        const wobble = bounce ? Math.sin((elapsed / duration) * Math.PI) * 0.12 : 0.06;
        ctx.rotate((index === 0 ? 1 : -1) * wobble);
        ctx.translate(-(curX + TILE / 2), -(curY + TILE / 2));
        drawTile(ctx, curX, curY, TILE, tile.cell, BLOCK);
        ctx.restore();
      });
    }

    // hint overlay
    if (hintCells && hintCells.size > 0) {
      const phase = (tick % 120) / 120;
      const glow = 0.6 + 0.4 * Math.sin(phase * Math.PI * 2);
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.lineWidth = 4.5;
      ctx.strokeStyle = `rgba(255,255,255,${0.65 + glow * 0.3})`;
      ctx.shadowColor = `rgba(255,255,255,${0.5 + glow * 0.5})`;
      ctx.shadowBlur = 22 + glow * 18;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
      for (const k of hintCells) {
        const [r, c] = unkey(k);
        const x = PADDING + c * TILE;
        const y = BOARD_TOP + r * TILE;
        roundRect(ctx, x + 1.5, y + 1.5, TILE - 3, TILE - 3, 13);
        ctx.stroke();
        ctx.fillStyle = `rgba(255,255,255,${0.08 + glow * 0.08})`;
        ctx.fill();
      }
      ctx.restore();
    }

    if (activeClears.length) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      activeClears.forEach((anim) => {
        const eased = easeOutCubic(anim.progress);
        anim.cells.forEach(([rr, cc]) => {
          const cx = PADDING + cc * TILE + TILE / 2;
          const cy = BOARD_TOP + rr * TILE + TILE / 2;
          const radius = (TILE / 2 + 8) * eased;
          const alpha = Math.max(0, 0.7 - anim.progress * 0.7);
          const burst = ctx.createRadialGradient(cx, cy, 4, cx, cy, radius);
          burst.addColorStop(0, `rgba(255,255,255,${0.55 * alpha})`);
          burst.addColorStop(0.6, `rgba(140,200,255,${0.45 * alpha})`);
          burst.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = burst;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = `rgba(255,255,255,${0.8 * alpha})`;
          ctx.lineWidth = 2 + anim.progress * 2;
          ctx.beginPath();
          ctx.arc(cx, cy, radius * 0.65, 0, Math.PI * 2);
          ctx.stroke();
        });
      });
      ctx.restore();
    }

    if (justShuffled) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(PADDING - 6, BOARD_TOP - 6, size * TILE + 12, size * TILE + 12);
      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px system-ui, -apple-system, Segoe UI, Roboto";
      ctx.textAlign = "center";
      ctx.fillText("No moves – Shuffled!", PADDING + (size * TILE) / 2, BOARD_TOP + (size * TILE) / 2);
      ctx.restore();
    }
  }, [board, logicalWidth, logicalHeight, dpr, size, selected, justShuffled, hintCells, tick]);

  // Internal tests once
  useEffect(() => {
    runInternalTests(BLOCK);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Idle hint: after 10s without action, highlight a valid swap (two tiles)
  useEffect(() => {
    const poll = setInterval(() => {
      if (busyRef.current || moves <= 0) { setHintCells(null); return; }
      const idleFor = Date.now() - lastActionAt;
      if (idleFor >= 10000) {
        const h = findFirstHint(boardRef.current, BLOCK);
        if (h) setHintCells(new Set([key(h.a.r, h.a.c), key(h.b.r, h.b.c)])); else setHintCells(null);
      } else {
        setHintCells(null);
      }
    }, 500);
    return () => clearInterval(poll);
  }, [moves, lastActionAt]);

  // Auto-shuffle watcher: whenever board is stable and has no valid moves
  useEffect(() => {
    if (busyRef.current || moves <= 0) return;
    // Avoid shuffling mid-cascade; ensure no matches are present
    const snapshot = boardRef.current;
    if (findMatchGroups(snapshot, BLOCK).length > 0) return;
    if (!hasAnyValidMove(snapshot, BLOCK)) {
      const shuffled = reshuffleBoard(snapshot, TYPES, BLOCK);
      setJustShuffled(true);
      playShuffle();
      commitBoard(shuffled);
      const t = setTimeout(() => setJustShuffled(false), 500);
      setLastActionAt(Date.now());
      setHintCells(null);
      return () => clearTimeout(t);
    }
  }, [moves, commitBoard]);

  // Pointer (mouse/touch)
  const handlePointer = async (clientX, clientY) => {
    if (busyRef.current) return;
    setLastActionAt(Date.now());
    setHintCells(null);
    const canvas = canvasRef.current;
    if (!canvas) return;
    const rect = canvas.getBoundingClientRect();
    // Use logical coordinates (canvas.style dimensions, not canvas.width/height which are scaled by dpr)
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    const localX = x - PADDING;
    const localY = y - BOARD_TOP;
    const c = Math.floor(localX / TILE);
    const r = Math.floor(localY / TILE);
    if (localY < 0 || localY >= size * TILE || localX < 0 || localX >= size * TILE) {
      setSelected(null);
      return;
    }
    const boardSnapshot = boardRef.current;
    const cell = boardSnapshot[r] && boardSnapshot[r][c];
    if (!cell || cell.type === BLOCK) return;

    if (!selected) {
      playSelect();
      setSelected({ r, c });
      return;
    }
    if (selected.r === r && selected.c === c) {
      playSelect();
      setSelected(null);
      return;
    }

    // Adjacent & playable swap only
    const selCell = boardSnapshot[selected.r][selected.c];
    if (!selCell || selCell.type === BLOCK || cell.type === BLOCK) {
      setSelected(null);
      return;
    }
    if (Math.abs(selected.r - r) + Math.abs(selected.c - c) !== 1) {
      playSelect();
      setSelected({ r, c });
      return;
    }

    // Attempt swap
    setBusyState(true);
    const r1 = selected.r, c1 = selected.c;
    setSelected(null);

    const tileA = cloneCell(boardSnapshot[r1][c1]);
    const tileB = cloneCell(boardSnapshot[r][c]);
    const swapped = swapCloned(boardSnapshot, r1, c1, r, c);
    const groups = findMatchGroups(swapped, BLOCK);
    if (groups.length === 0) {
      playInvalid();
      animationsRef.current.swap = {
        start: timeNow(),
        duration: 220,
        total: 440,
        bounce: true,
        tiles: [
          { cell: tileA, from: { r: r1, c: c1 }, to: { r, c } },
          { cell: tileB, from: { r, c }, to: { r: r1, c: c1 } }
        ]
      };
      commitBoard(boardSnapshot.slice());
      await sleep(440);
      setBusyState(false);
      return;
    }

    // Commit + resolve
    playSwap();
    animationsRef.current.swap = {
      start: timeNow(),
      duration: 200,
      total: 200,
      bounce: false,
      tiles: [
        { cell: tileA, from: { r: r1, c: c1 }, to: { r, c } },
        { cell: tileB, from: { r, c }, to: { r: r1, c: c1 } }
      ]
    };
    commitBoard(swapped);
    setMoves((m) => {
      const newMoves = Math.max(0, m - 1);
      postHudMessage({ score, best, moves: newMoves });
      return newMoves;
    });
    lastSwapRef.current = { a: { r: r1, c: c1 }, b: { r, c } };
    const finalBoard = await resolveCascades(swapped);

    setLastActionAt(Date.now());
    setHintCells(null);

    // Auto‑shuffle if stuck (use the final settled board)
    if (!hasAnyValidMove(finalBoard, BLOCK)) {
      const shuffled = reshuffleBoard(finalBoard, TYPES, BLOCK);
      setJustShuffled(true);
      playShuffle();
      commitBoard(shuffled);
      await sleep(500);
      setJustShuffled(false);
      setLastActionAt(Date.now());
      setHintCells(null);
    }

    setBusyState(false);
  };

  const resolveCascades = async (startBoard) => {
    let cur = startBoard;
    let chain = 0;
    while (true) {
      const groups = findMatchGroups(cur, BLOCK);
      if (groups.length === 0) break;
      chain++;

      const specialsToPlace = [];
      const toClear = new Set();

      for (const g of groups) {
        const len = g.cells.length;
        for (const rc of g.cells) toClear.add(key(rc.r, rc.c));
        if (len >= 5) {
          const spawnAt = pickSpawn(cur, g, lastSwapRef.current);
          specialsToPlace.push({ ...spawnAt, kind: "bomb" });
        } else if (len === 4) {
          const spawnAt = pickSpawn(cur, g, lastSwapRef.current);
          specialsToPlace.push({ ...spawnAt, kind: g.dir === "row" ? "stripeH" : "stripeV" });
        }
      }

      const expanded = expandBySpecials(cur, toClear, BLOCK);
      for (const k of expanded) toClear.add(k);

      const burstCells = Array.from(toClear).map(unkey);
      if (burstCells.length) {
        animationsRef.current.clears.push({ start: timeNow(), duration: 360, cells: burstCells });
      }

      let cleared = clearCells(cur, toClear);
      cleared = placeSpecials(cleared, specialsToPlace, TYPES);

      const points = Math.round(toClear.size * 10 * chain);
      setScore((s) => {
        const next = s + points;
        setBest((b) => {
          const updated = Math.max(b, next);
          postHudMessage({ score: next, best: updated, moves });
          return updated;
        });
        return next;
      });
      playMatch(chain);
      commitBoard(cleared);
      await sleep(120);

      const falling = [];
      const gravityBoard = applyGravity(cleared, BLOCK, falling);
      if (falling.length) {
        animationsRef.current.falls.push({ start: timeNow(), duration: 260, items: falling });
        playCascade();
      }
      cur = gravityBoard;
      commitBoard(cur);
      await sleep(140);

      const spawned = [];
      const refilled = refillBoard(cur, TYPES, BLOCK, spawned);
      if (spawned.length) {
        animationsRef.current.spawns.push({ start: timeNow(), duration: 260, cells: spawned });
        playSpawn();
      }
      cur = refilled;
      commitBoard(cur);
      await sleep(120);
    }
    return cur;
  };

  const blockTouch = (e) => {
    if (!e) return;
    if (typeof e.preventDefault === "function") e.preventDefault();
    if (typeof e.stopPropagation === "function") e.stopPropagation();
  };

  const processPress = (event) => {
    if (!event) return;
    blockTouch(event);
    setLastActionAt(Date.now());
    setHintCells(null);
    let x;
    let y;
    if (typeof event.clientX === "number" && typeof event.clientY === "number") {
      x = event.clientX;
      y = event.clientY;
    } else if (event.touches && event.touches.length > 0) {
      x = event.touches[0].clientX;
      y = event.touches[0].clientY;
    } else if (event.changedTouches && event.changedTouches.length > 0) {
      x = event.changedTouches[0].clientX;
      y = event.changedTouches[0].clientY;
    }
    if (typeof x === "number" && typeof y === "number") {
      handlePointer(x, y);
    }
  };

  const onPointerDown = (event) => {
    inputModeRef.current = "pointer";
    processPress(event);
  };

  const onPointerUp = () => {
    if (inputModeRef.current === "pointer") {
      inputModeRef.current = null;
    }
  };

  const onMouseDown = (event) => {
    if (inputModeRef.current && inputModeRef.current !== "mouse") {
      if (inputModeRef.current === "pointer") return;
    }
    inputModeRef.current = "mouse";
    processPress(event);
  };

  const onMouseUp = () => {
    if (inputModeRef.current === "mouse") {
      inputModeRef.current = null;
    }
  };

  const onTouchStart = (event) => {
    if (inputModeRef.current && inputModeRef.current !== "touch") {
      if (inputModeRef.current === "pointer") return;
    }
    inputModeRef.current = "touch";
    processPress(event);
  };

  const onTouchEnd = (event) => {
    blockTouch(event);
    if (inputModeRef.current === "touch" || inputModeRef.current === "pointer") {
      inputModeRef.current = null;
    }
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const listenerOptions = { passive: false };
    const pointerDownListener = (event) => onPointerDown(event);
    const pointerUpListener = () => onPointerUp();
    const pointerCancelListener = () => onPointerUp();
    const mouseDownListener = (event) => onMouseDown(event);
    const mouseUpListener = () => onMouseUp();
    const touchStartListener = (event) => onTouchStart(event);
    const touchMoveListener = (event) => blockTouch(event);
    const touchEndListener = (event) => onTouchEnd(event);
    const touchCancelListener = (event) => onTouchEnd(event);

    canvas.addEventListener("pointerdown", pointerDownListener, listenerOptions);
    canvas.addEventListener("pointerup", pointerUpListener, listenerOptions);
    canvas.addEventListener("pointercancel", pointerCancelListener, listenerOptions);
    canvas.addEventListener("mousedown", mouseDownListener, listenerOptions);
    canvas.addEventListener("mouseup", mouseUpListener, listenerOptions);
    canvas.addEventListener("touchstart", touchStartListener, listenerOptions);
    canvas.addEventListener("touchmove", touchMoveListener, listenerOptions);
    canvas.addEventListener("touchend", touchEndListener, listenerOptions);
    canvas.addEventListener("touchcancel", touchCancelListener, listenerOptions);
    return () => {
      canvas.removeEventListener("pointerdown", pointerDownListener, listenerOptions);
      canvas.removeEventListener("pointerup", pointerUpListener, listenerOptions);
      canvas.removeEventListener("pointercancel", pointerCancelListener, listenerOptions);
      canvas.removeEventListener("mousedown", mouseDownListener, listenerOptions);
      canvas.removeEventListener("mouseup", mouseUpListener, listenerOptions);
      canvas.removeEventListener("touchstart", touchStartListener, listenerOptions);
      canvas.removeEventListener("touchmove", touchMoveListener, listenerOptions);
      canvas.removeEventListener("touchend", touchEndListener, listenerOptions);
      canvas.removeEventListener("touchcancel", touchCancelListener, listenerOptions);
    };
  });

  const canPlay = moves > 0;

  // Expose GameAPI for Swift to call
  useEffect(() => {
    if (typeof window === "undefined") return;
    if (!window.GameAPI) window.GameAPI = {};
    window.GameAPI.newGame = function () {
      newGame(levelIndex);
    };
    window.GameAPI.setBestScore = function (value) {
      const numeric = typeof value === "number" ? value : Number(value || 0);
      if (numeric > best) {
        setBest(numeric);
        postHudMessage({ score: numeric, best: numeric, moves });
      }
    };
  }, [levelIndex, best, moves]);

  // Send HUD updates to Swift whenever values change
  useEffect(() => {
    postHudMessage({ score, best, moves });
  }, [score, best, moves]);

  const containerStyle = {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    width: "100%",
    height: "100%",
    gap: 18,
  };
  const stageStyle = {
    position: "relative",
    width: logicalWidth,
    height: logicalHeight,
  };

  const handleNewGameTap = (event) => {
    if (event) {
      if (typeof event.preventDefault === "function") event.preventDefault();
      if (typeof event.stopPropagation === "function") event.stopPropagation();
    }
    newGame(levelIndex);
  };

  const buttonStyle = {
    padding: "12px 22px",
    borderRadius: 999,
    border: "none",
    fontSize: "16px",
    fontWeight: 700,
    color: "#06152a",
    background: "linear-gradient(135deg, #7ee0ff 0%, #5fb1ff 45%, #9f94ff 100%)",
    boxShadow: "0 14px 28px rgba(4, 16, 32, 0.35), 0 0 0 2px rgba(255, 255, 255, 0.18)",
    cursor: "pointer",
    letterSpacing: 0.3,
    transition: "transform 0.18s ease, box-shadow 0.18s ease",
  };
  const buttonWrapperStyle = {
    display: "flex",
    justifyContent: "center",
    width: logicalWidth,
    maxWidth: "100%",
  };

  const newGameButton = React.createElement(
    "button",
    {
      type: "button",
      onClick: handleNewGameTap,
      style: buttonStyle,
      onMouseDown: (event) => event.stopPropagation(),
      onTouchStart: (event) => {
        if (event && typeof event.stopPropagation === "function") event.stopPropagation();
      },
    },
    moves > 0 ? "New Game" : "Play Again"
  );

  const overlay = !canPlay
    ? React.createElement(
        "div",
        {
          style: {
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            zIndex: 10,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
          },
        },
        React.createElement(
          "div",
          {
            style: {
              backgroundColor: "rgba(0, 0, 0, 0.6)",
              padding: "18px 24px",
              borderRadius: "20px",
              textAlign: "center",
              color: "#ffffff",
              backdropFilter: "blur(6px)",
              WebkitBackdropFilter: "blur(6px)",
            },
          },
          React.createElement(
            "div",
            { style: { fontSize: "18px", fontWeight: 600, marginBottom: "6px" } },
            "Out of moves"
          ),
          React.createElement(
            "div",
            { style: { fontSize: "14px", opacity: 0.9 } },
            "Tap New Game to play again."
          )
        )
      )
    : null;

  const canvasStyle = {
    opacity: canPlay ? 1 : 0.7,
    touchAction: "none",
    userSelect: "none",
    WebkitUserSelect: "none",
    cursor: "pointer",
    display: "block",
  };

  return React.createElement(
    "div",
    { style: containerStyle },
    React.createElement(
      "div",
      { style: stageStyle },
      React.createElement("canvas", {
        ref: canvasRef,
        style: canvasStyle,
      }),
      overlay
    ),
    React.createElement("div", { style: buttonWrapperStyle }, newGameButton)
  );
}


// ---------------- Board creation (robust) ----------------

function makeFreshBoard(level, types, BLOCK) {
  const n = level.size;
  let b = makeBoard(level, types, BLOCK);

  // Ensure: no immediate matches and (if layout allows) at least one valid move
  let guard = 0;
  const layoutPossible = levelHasOrthogonalAdjacency(level);
  while (guard++ < 200) {
    const noInstant = findMatchGroups(b, BLOCK).length === 0;
    const okMove = !layoutPossible || hasAnyValidMove(b, BLOCK);
    if (isValidBoard(b, n) && noInstant && okMove) break;
    b = makeBoard(level, types, BLOCK);
  }
  return b;
}

function makeBoard(level, types, BLOCK) {
  const n = level.size;
  const b = Array.from({ length: n }, (_, r) =>
    Array.from({ length: n }, (_, c) =>
      level.mask(r, c)
        ? { type: randInt(types), id: nextId(), special: "none", keys: randKeys() }
        : { type: BLOCK, id: nextId(), special: "none", keys: { u: false, r: false, d: false, l: false } }
    )
  );
  // Light pruning of instant 3‑lines (only on playable cells) under key rules
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (b[r][c].type === BLOCK) continue;
      // change type if we accidentally formed a key‑connected triple horizontally
      if (c >= 2 && connectedH(b[r][c - 2], b[r][c - 1]) && connectedH(b[r][c - 1], b[r][c]) &&
          b[r][c - 2].type === b[r][c - 1].type && b[r][c - 1].type === b[r][c].type) {
        b[r][c].type = (b[r][c].type + 1) % types;
      }
      // change type for vertical accidental triple
      if (r >= 2 && connectedV(b[r - 2][c], b[r - 1][c]) && connectedV(b[r - 1][c], b[r][c]) &&
          b[r - 2][c].type === b[r - 1][c].type && b[r - 1][c].type === b[r][c].type) {
        b[r][c].type = (b[r][c].type + 1) % types;
      }
    }
  }
  return b;
}

function isValidBoard(b, n) {
  if (!Array.isArray(b) || b.length !== n) return false;
  for (let r = 0; r < n; r++) {
    if (!Array.isArray(b[r]) || b[r].length !== n) return false;
    for (let c = 0; c < n; c++) {
      const cell = b[r][c];
      if (!cell || typeof cell.type !== "number" || typeof cell.id !== "number") return false;
      if (!cell.keys) return false;
    }
  }
  return true;
}

function levelHasOrthogonalAdjacency(level) {
  const n = level.size;
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (!level.mask(r, c)) continue;
      if (r + 1 < n && level.mask(r + 1, c)) return true;
      if (c + 1 < n && level.mask(r, c + 1)) return true;
    }
  }
  return false;
}

// ---------------- Swap / Match / Resolve ----------------

function swapCloned(b, r1, c1, r2, c2) {
  const out = b.map((row) => row.map((cell) => cloneCell(cell)));
  const tmp = out[r1][c1];
  out[r1][c1] = out[r2][c2];
  out[r2][c2] = tmp;
  return out;
}

// Bending-chain keyed matching (orthogonal connectivity with aligned keys)
function findMatchGroups(b, BLOCK) {
  const n = b.length;
  const seen = Array.from({ length: n }, () => Array(n).fill(false));
  const groups = [];

  const inb = (r, c) => r >= 0 && r < n && c >= 0 && c < n;
  const neighs = [
    { dr: 0, dc: 1, can: (a, d) => canLinkH(a, d) && a.type === d.type },
    { dr: 1, dc: 0, can: (a, d) => canLinkV(a, d) && a.type === d.type },
    { dr: 0, dc: -1, can: (a, d) => canLinkH(d, a) && a.type === d.type }, // reverse horiz
    { dr: -1, dc: 0, can: (a, d) => canLinkV(d, a) && a.type === d.type }, // reverse vert
  ];

  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (seen[r][c]) continue;
      const start = b[r][c];
      if (!start || start.type < 0 || start.type === BLOCK) { seen[r][c] = true; continue; }

      // BFS component under keyed connectivity for same type
      const queue = [{ r, c }];
      const comp = [];
      seen[r][c] = true;
      while (queue.length) {
        const cur = queue.shift();
        comp.push(cur);
        for (const { dr, dc, can } of neighs) {
          const rr = cur.r + dr, cc = cur.c + dc;
          if (!inb(rr, cc) || seen[rr][cc]) continue;
          const A = b[cur.r][cur.c];
          const D = b[rr][cc];
          if (!D) continue;
          if (D.type >= 0 && can(A, D)) {
            seen[rr][cc] = true;
            queue.push({ r: rr, c: cc });
          }
        }
      }

      if (comp.length >= 3) {
        // Stripe orientation inferred from the longest straight segment within the component
        const set = new Set(comp.map(({ r, c }) => key(r, c)));
        const hMax = longestLine(set, true);
        const vMax = longestLine(set, false);
        const dir = hMax >= vMax ? "row" : "col";
        groups.push({ dir, cells: comp });
      }
    }
  }
  return groups;
}

function longestLine(kset, horizontal) {
  // Count the maximum contiguous horizontal (or vertical) length inside the set.
  let max = 1;
  const coords = Array.from(kset).map(unkey);
  const byRow = new Map();
  const byCol = new Map();
  for (const [r, c] of coords) {
    if (!byRow.has(r)) byRow.set(r, []);
    byRow.get(r).push(c);
    if (!byCol.has(c)) byCol.set(c, []);
    byCol.get(c).push(r);
  }
  if (horizontal) {
    for (const [r, arrRaw] of byRow.entries()) {
      const arr = arrRaw.sort((a, b) => a - b);
      let run = 1;
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] === arr[i - 1] + 1) run++; else { max = Math.max(max, run); run = 1; }
      }
      max = Math.max(max, run);
    }
  } else {
    for (const [c, arrRaw] of byCol.entries()) {
      const arr = arrRaw.sort((a, b) => a - b);
      let run = 1;
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] === arr[i - 1] + 1) run++; else { max = Math.max(max, run); run = 1; }
      }
      max = Math.max(max, run);
    }
  }
  return max;
}

function expandBySpecials(b, base, BLOCK) {
  const n = b.length;
  const extra = new Set();
  const add = (r, c) => {
    if (b[r][c].type === BLOCK) return;
    extra.add(key(r, c));
  };
  for (const k of base) {
    const [r, c] = unkey(k);
    const cell = b[r][c];
    if (cell.type === BLOCK) continue;
    if (cell.special === "stripeH") {
      for (let x = 0; x < n; x++) if (b[r][x].type !== BLOCK) add(r, x);
    } else if (cell.special === "stripeV") {
      for (let y = 0; y < n; y++) if (b[y][c].type !== BLOCK) add(y, c);
    } else if (cell.special === "bomb") {
      for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
        const rr = r + dr, cc = c + dc;
        if (rr >= 0 && rr < n && cc >= 0 && cc < n && b[rr][cc].type !== BLOCK) add(rr, cc);
      }
    }
  }
  return extra;
}

function clearCells(b, toClear) {
  const out = b.map((row) => row.map((c) => cloneCell(c)));
  for (const k of toClear) {
    const [r, c] = unkey(k);
    if (out[r][c].type >= 0) out[r][c] = { ...out[r][c], type: -1, special: "none" };
  }
  return out;
}

function placeSpecials(b, list, types) {
  const n = b.length;
  const out = b.map((row) => row.map((c) => cloneCell(c)));
  for (const s of list) {
    if (s.r < 0 || s.r >= n || s.c < 0 || s.c >= n) continue;
    if (out[s.r][s.c].type === -1) {
      out[s.r][s.c] = { type: randInt(types), id: nextId(), special: s.kind, keys: randKeys() };
    } else if (out[s.r][s.c].type >= 0) {
      out[s.r][s.c] = { ...out[s.r][s.c], special: s.kind };
    }
  }
  return out;
}

// Gravity segmented by blocks
function applyGravity(b, BLOCK, moves) {
  const n = b.length;
  const origin = moves ? new Map() : null;
  if (origin) {
    for (let r = 0; r < n; r++) {
      for (let c = 0; c < n; c++) {
        const cell = b[r][c];
        if (cell.type >= 0) origin.set(cell.id, { r, c });
      }
    }
  }
  const out = b.map((row) => row.map((c) => cloneCell(c)));
  for (let c = 0; c < n; c++) {
    let wr = n - 1;
    for (let r = n - 1; r >= 0; r--) {
      const cell = out[r][c];
      if (cell.type === BLOCK) {
        wr = r - 1;
      } else if (cell.type >= 0) {
        if (wr !== r) {
          out[wr][c] = cloneCell(cell);
          out[r][c] = { ...cell, type: -1, special: "none" };
        }
        wr--;
      }
    }
    for (let r = wr; r >= 0; r--) {
      if (out[r][c].type !== BLOCK) {
        out[r][c] = { ...out[r][c], type: -1, special: "none" };
      } else {
        wr = r - 1;
      }
    }
  }
  if (origin && moves) {
    for (let r = 0; r < n; r++) {
      for (let c = 0; c < n; c++) {
        const cell = out[r][c];
        if (cell.type >= 0) {
          const prev = origin.get(cell.id);
          if (prev && (prev.r !== r || prev.c !== c)) {
            moves.push({ id: cell.id, from: prev, to: { r, c } });
          }
        }
      }
    }
  }
  return out;
}

function refillBoard(b, types, BLOCK, spawned) {
  const n = b.length;
  const out = b.map((row) => row.map((c) => cloneCell(c)));
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (out[r][c].type === -1) {
        const newCell = { type: randInt(types), id: nextId(), special: "none", keys: randKeys() };
        out[r][c] = newCell;
        if (spawned) spawned.push({ r, c });
      }
    }
  }
  return out;
}

// Reshuffle playable tiles until: no instant matches; and if possible layout, at least one valid move.
function reshuffleBoard(b, types, BLOCK) {
  const n = b.length;
  // Lock specials in place; only shuffle normal (special === "none") playable tiles
  const movable = [];
  const vals = [];
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const cell = b[r][c];
      if (cell.type >= 0 && cell.special === "none") {
        movable.push({ r, c });
        vals.push({ type: cell.type, keys: { ...cell.keys } });
      }
    }
  }
  const layoutPossible = boardHasOrthogonalAdjacency(b, BLOCK);
  let guard = 0;
  while (guard++ < 500) {
    shuffle(vals);
    // Start from an exact clone so specials and blocks remain untouched
    const out = b.map((row) => row.map((cell) => cloneCell(cell)));
    movable.forEach((rc, i) => {
      const cur = out[rc.r][rc.c];
      out[rc.r][rc.c] = { type: vals[i].type, id: cur.id, special: cur.special, keys: { ...vals[i].keys } };
    });
    const noInstant = findMatchGroups(out, BLOCK).length === 0;
    if (!noInstant) continue;
    if (!layoutPossible || hasAnyValidMove(out, BLOCK)) return out;
  }
  // fallback: rebuild only the movable cells randomly while keeping specials fixed
  const out = b.map((row) => row.map((cell) => cloneCell(cell)));
  movable.forEach((rc) => {
    const cur = out[rc.r][rc.c];
    out[rc.r][rc.c] = { type: randInt(types), id: cur.id, special: cur.special, keys: randKeys() };
  });
  return out;
}

function hasAnyValidMove(b, BLOCK) {
  const n = b.length;
  const trySwap = (r1, c1, r2, c2) => {
    if (b[r1][c1].type < 0 || b[r2][c2].type < 0) return false;
    const swapped = swapCloned(b, r1, c1, r2, c2);
    return findMatchGroups(swapped, BLOCK).length > 0;
  };
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (b[r][c].type < 0) continue;
      if (c + 1 < n && b[r][c + 1].type >= 0 && trySwap(r, c, r, c + 1)) return true;
      if (r + 1 < n && b[r + 1][c].type >= 0 && trySwap(r, c, r + 1, c)) return true;
    }
  }
  return false;
}

function findFirstHint(b, BLOCK) {
  const n = b.length;
  const createsMatch = (r1, c1, r2, c2) => {
    if (b[r1][c1].type < 0 || b[r2][c2].type < 0) return false;
    const swapped = swapCloned(b, r1, c1, r2, c2);
    return findMatchGroups(swapped, BLOCK).length > 0;
  };
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (b[r][c].type < 0) continue;
      if (c + 1 < n && b[r][c + 1].type >= 0 && createsMatch(r, c, r, c + 1)) return { a: { r, c }, b: { r, c: c + 1 } };
      if (r + 1 < n && b[r + 1][c].type >= 0 && createsMatch(r, c, r + 1, c)) return { a: { r, c }, b: { r: r + 1, c } };
    }
  }
  return null;
}

// ---------------- Utilities ----------------

function randInt(max) { return Math.floor(Math.random() * max); }
function key(r, c) { return r + "," + c; }
function unkey(k) { const [r, c] = k.split(",").map(Number); return [r, c]; }
function sleep(ms) { return new Promise((res) => setTimeout(res, ms)); }
function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }

function boardHasOrthogonalAdjacency(b, BLOCK) {
  const n = b.length;
  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (b[r][c].type === BLOCK) continue;
      if (r + 1 < n && b[r + 1][c].type !== BLOCK) return true;
      if (c + 1 < n && b[r][c + 1].type !== BLOCK) return true;
    }
  }
  return false;
}

function roundRect(ctx, x, y, w, h, r) {
  const min = Math.min(w, h);
  if (r > min / 2) r = min / 2;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

function drawHUD(ctx, score, moves, best, width, hudHeight, padding) {
  ctx.save();
  const barX = padding;
  const barY = padding;
  const barH = hudHeight - padding * 2;
  const barW = width - barX * 2;
  ctx.globalAlpha = 0.97;
  roundRect(ctx, barX, barY, barW, barH, 22);
  const lg = ctx.createLinearGradient(barX, barY, barX, barY + barH);
  lg.addColorStop(0, "rgba(10, 28, 52, 0.95)");
  lg.addColorStop(1, "rgba(5, 18, 34, 0.95)");
  ctx.fillStyle = lg;
  ctx.fill();
  ctx.globalAlpha = 1;

  ctx.strokeStyle = "rgba(31, 77, 122, 0.55)";
  ctx.lineWidth = 1.5;
  roundRect(ctx, barX + 1.5, barY + 1.5, barW - 3, barH - 3, 20);
  ctx.stroke();

  const itemWidth = barW / 3;
  const labels = [
    { label: "Score", value: score },
    { label: "Best", value: best },
    { label: "Moves", value: moves }
  ];
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.font = "600 14px 'Baloo 2', system-ui";
  labels.forEach((item, idx) => {
    const itemX = barX + idx * itemWidth;
    if (idx > 0) {
      ctx.strokeStyle = "rgba(116, 161, 212, 0.2)";
      ctx.lineWidth = 1.1;
      ctx.beginPath();
      ctx.moveTo(itemX, barY + 12);
      ctx.lineTo(itemX, barY + barH - 12);
      ctx.stroke();
    }
    const centerX = itemX + itemWidth / 2;
    ctx.fillStyle = "#8fb8ff";
    ctx.fillText(item.label, centerX, barY + barH / 2 - 12);
    ctx.font = "700 20px 'Baloo 2', system-ui";
    ctx.fillStyle = "#f4f8ff";
    ctx.fillText(String(item.value), centerX, barY + barH / 2 + 8);
    ctx.font = "600 14px 'Baloo 2', system-ui";
  });
  ctx.restore();
}

// --- Key rules helpers ---
function canLinkH(a, b) { return a.type >= 0 && b.type >= 0 && a.keys.r && b.keys.l; }
function canLinkV(a, b) { return a.type >= 0 && b.type >= 0 && a.keys.d && b.keys.u; }
function connectedH(a, b) { return a.type === b.type && canLinkH(a, b); }
function connectedV(a, b) { return a.type === b.type && canLinkV(a, b); }

function randKeys() {
  // Random multi‑sided keys; bias towards 2 sides on average
  const patterns = [
    { u: true, r: false, d: true, l: false },
    { u: false, r: true, d: false, l: true },
    { u: true, r: true, d: false, l: false },
    { u: false, r: true, d: true, l: false },
    { u: false, r: false, d: true, l: true },
    { u: true, r: false, d: false, l: true },
    { u: true, r: true, d: true, l: false },
    { u: false, r: true, d: true, l: true },
    { u: true, r: false, d: true, l: true },
    { u: true, r: true, d: false, l: true },
  ];
  return patterns[randInt(patterns.length)];
}

// Sleek, playful tile design with high contrast colors
function drawTile(ctx, x, y, size, cell, BLOCK) {
  const palette = [
    { top: "#ffe9ff", mid: "#ff9be2", bottom: "#ff55b8", accent: "#ffd6f6", glow: "rgba(255, 126, 220, 0.45)" },
    { top: "#fff3d8", mid: "#ffd072", bottom: "#ffac3f", accent: "#ffeab1", glow: "rgba(255, 186, 99, 0.45)" },
    { top: "#ddfff6", mid: "#6ff1cf", bottom: "#17d4a9", accent: "#c6fff2", glow: "rgba(86, 232, 189, 0.45)" },
    { top: "#e6e3ff", mid: "#a998ff", bottom: "#786aff", accent: "#d4ceff", glow: "rgba(142, 126, 255, 0.45)" },
    { top: "#e0f1ff", mid: "#7bc1ff", bottom: "#3992ff", accent: "#c7e4ff", glow: "rgba(77, 161, 255, 0.45)" },
    { top: "#ecffe3", mid: "#a8ff78", bottom: "#52dc5e", accent: "#d6ffca", glow: "rgba(116, 234, 112, 0.45)" }
  ];
  const paletteEntry = palette[((cell.type % palette.length) + palette.length) % palette.length];

  if (cell.type === BLOCK) {
    ctx.save();
    roundRect(ctx, x + 3, y + 3, size - 6, size - 6, 16);
    const blocked = ctx.createLinearGradient(x, y, x + size, y + size);
    blocked.addColorStop(0, "#c5b7ff");
    blocked.addColorStop(1, "#9a8aff");
    ctx.fillStyle = blocked;
    ctx.fill();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    roundRect(ctx, x + 5, y + 5, size - 10, size - 10, 14);
    ctx.stroke();
    ctx.setLineDash([6, 6]);
    ctx.strokeStyle = "rgba(83, 52, 173, 0.35)";
    roundRect(ctx, x + 6, y + 6, size - 12, size - 12, 12);
    ctx.stroke();
    ctx.restore();
    return;
  }

  const cx = x + size / 2;
  const cy = y + size / 2;

  ctx.save();
  ctx.shadowColor = paletteEntry.glow;
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 6;
  const bodyRadius = size * 0.22;
  roundRect(ctx, x + 2, y + 4, size - 4, size - 6, bodyRadius);
  const candy = ctx.createLinearGradient(x, y, x, y + size);
  candy.addColorStop(0, paletteEntry.top);
  candy.addColorStop(0.45, paletteEntry.mid);
  candy.addColorStop(1, paletteEntry.bottom);
  ctx.fillStyle = candy;
  ctx.fill();
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(255,255,255,0.7)";
  roundRect(ctx, x + 2.5, y + 4.5, size - 5, size - 7, bodyRadius * 0.85);
  ctx.stroke();
  ctx.restore();

  // key notches as rounded triangular cut-outs
  const notchWidth = size * 0.36;
  const notchDepth = size * 0.22;
  const notchCurve = size * 0.06;
  const drawRoundedNotch = (direction) => {
    ctx.save();
    ctx.translate(cx, cy);
    const rotation = direction === "u" ? 0 : direction === "r" ? Math.PI / 2 : direction === "d" ? Math.PI : -Math.PI / 2;
    ctx.rotate(rotation);
    ctx.translate(-cx, -cy);

    const baseY = y + 1.5;
    const tipY = baseY + notchDepth;
    const leftX = cx - notchWidth / 2;
    const rightX = cx + notchWidth / 2;
    const sideEase = notchWidth * 0.18;
    const tipEase = notchCurve * 0.9;

    const notchFill = ctx.createLinearGradient(cx, baseY, cx, tipY);
    notchFill.addColorStop(0, "rgba(16, 11, 32, 0.9)");
    notchFill.addColorStop(1, "rgba(2, 2, 6, 0.7)");
    ctx.fillStyle = notchFill;

    ctx.beginPath();
    ctx.moveTo(leftX, baseY);
    ctx.quadraticCurveTo(leftX + sideEase * 0.4, baseY + notchCurve * 0.25, leftX + sideEase, baseY + notchCurve * 0.9);
    ctx.lineTo(cx - tipEase, tipY - notchCurve * 0.45);
    ctx.quadraticCurveTo(cx, tipY, cx + tipEase, tipY - notchCurve * 0.45);
    ctx.lineTo(rightX - sideEase, baseY + notchCurve * 0.9);
    ctx.quadraticCurveTo(rightX - sideEase * 0.4, baseY + notchCurve * 0.25, rightX, baseY);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  };
  if (cell.keys.u) drawRoundedNotch("u");
  if (cell.keys.d) drawRoundedNotch("d");
  if (cell.keys.l) drawRoundedNotch("l");
  if (cell.keys.r) drawRoundedNotch("r");

  // Specials - enhanced visual effects
  const center = size * 0.5;
  if (cell.special === "stripeH") {
    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = "rgba(255,255,255,0.85)";
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 5;
    ctx.lineCap = "round";
    for (let i = -1; i <= 1; i++) {
      ctx.beginPath();
      ctx.moveTo(x + 10, y + center + i * 6);
      ctx.lineTo(x + size - 10, y + center + i * 6);
      ctx.stroke();
    }
    ctx.restore();
  } else if (cell.special === "stripeV") {
    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = "rgba(255,255,255,0.85)";
    ctx.strokeStyle = "rgba(255,255,255,0.95)";
    ctx.lineWidth = 5;
    ctx.lineCap = "round";
    for (let i = -1; i <= 1; i++) {
      ctx.beginPath();
      ctx.moveTo(x + center + i * 6, y + 10);
      ctx.lineTo(x + center + i * 6, y + size - 10);
      ctx.stroke();
    }
    ctx.restore();
  } else if (cell.special === "bomb") {
    ctx.save();
    const bombSize = size * 0.22;
    const bombGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, bombSize);
    bombGrad.addColorStop(0, "#ffffff");
    bombGrad.addColorStop(0.45, paletteEntry.accent);
    bombGrad.addColorStop(1, paletteEntry.bottom);
    ctx.fillStyle = bombGrad;
    ctx.shadowBlur = 10;
    ctx.shadowColor = paletteEntry.glow;
    ctx.beginPath();
    ctx.arc(cx, cy, bombSize, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(cx - bombSize * 0.3, cy - bombSize * 0.3, bombSize * 0.35, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}


// Spawn selection favors the last‑swapped position in the group, else first
function pickSpawn(b, g, last) {
  const arr = g.cells;
  if (last) {
    const hitB = arr.find((p) => p.r === last.b.r && p.c === last.b.c); if (hitB) return hitB;
    const hitA = arr.find((p) => p.r === last.a.r && p.c === last.a.c); if (hitA) return hitA;
  }
  return arr[0];
}

// ---------------- Internal Tests ----------------
// These run once on mount and log to console. They should never throw.
function runInternalTests(BLOCK) {
  try {
    const A = 0, B = 1, C = 2;
    const emptyKeys = { u: false, r: false, d: false, l: false };
    const mk = (g) => g.map((row, r) => row.map((t, c) => ({ type: t, id: r*10+c, special: "none", keys: { ...emptyKeys } })));

    // helper to set horizontal links for a row segment [c1..c2]
    const linkRow = (b, r, c1, c2) => {
      for (let c = c1; c < c2; c++) { b[r][c].keys.r = true; b[r][c+1].keys.l = true; }
    };
    // helper to set vertical links for a col segment [r1..r2]
    const linkCol = (b, c, r1, r2) => {
      for (let r = r1; r < r2; r++) { b[r][c].keys.d = true; b[r+1][c].keys.u = true; }
    };

    // Test 1: horizontal match requires keys
    const boardRow = mk([
      [A, A, A, B, C, C, B, A],
      [B, C, B, C, B, C, B, C],
      [C, B, C, B, C, B, C, B],
      [A, B, C, A, B, C, A, B],
      [A, B, C, A, B, C, A, B],
      [A, B, C, A, B, C, A, B],
      [A, B, C, A, B, C, A, B],
      [A, B, C, A, B, C, A, B],
    ]);
    // no keys yet -> no match
    const g0 = findMatchGroups(boardRow, BLOCK);
    if (g0.length !== 0) console.warn("Test1a: expected no matches without keys");
    // add keys for first three in row 0 -> now should match
    linkRow(boardRow, 0, 0, 2);
    const g1 = findMatchGroups(boardRow, BLOCK);
    if (!(g1.some(g => g.dir === "row" && g.cells.length >= 3 && g.cells[0].r === 0))) {
      console.warn("Test1b: expected a key‑connected horizontal match on row 0");
    }

    // Test 2: vertical requires keys
    const boardCol = mk([
      [A, B, C],
      [A, C, B],
      [A, B, C],
      [B, C, B],
      [C, B, C],
      [B, C, B],
      [C, B, C],
      [B, C, B],
    ]);
    // add keys for first col A‑A‑A
    linkCol(boardCol, 0, 0, 2);
    const g2 = findMatchGroups(boardCol, BLOCK);
    if (!(g2.some(g => g.dir === "col" && g.cells.length >= 3))) {
      console.warn("Test2: expected a key‑connected vertical match");
    }

    // Test 3: special expansion (stripe clears row)
    const boardStripe = mk([
      [A, A, A],
      [B, B, B],
      [C, C, C],
    ]);
    // keys only matter for spawning, not for effect; force a stripe and then expand
    boardStripe[1][1].special = "stripeH";
    const base = new Set([key(1,1)]);
    const exp = expandBySpecials(boardStripe, base, BLOCK);
    const rowClearCount = Array.from(exp).filter(k => unkey(k)[0] === 1).length;
    if (rowClearCount !== 3) console.warn("Test3: stripeH should clear its whole row");

    // Test 4: placeSpecials marks cell as special
    const after = placeSpecials(boardStripe, [{ r: 0, c: 0, kind: "bomb" }], 6);
    if (after[0][0].special !== "bomb") console.warn("Test4: expected bomb at 0,0");

    // Test 5: reshuffle produces board with no instant matches
    const sample = mk([
      [A, B, C, A],
      [B, C, A, B],
      [C, A, B, C],
      [A, B, C, A],
    ]);
    // link a few to create potential matches, then reshuffle should remove any instant matches
    linkRow(sample, 0, 0, 2);
    linkCol(sample, 1, 0, 2);
    const shuffled = reshuffleBoard(sample, 3, BLOCK);
    const ok5 = findMatchGroups(shuffled, BLOCK).length === 0; // no instant matches
    if (!ok5) console.warn("Test5: reshuffle should remove instant matches under key rules");

    // Test 6: L‑shape (bending chain) should match when keys form a corner
    const L = mk([
      [A, A, B],
      [B, A, B],
      [B, A, B],
    ]);
    // keys: (0,0)-(0,1) horizontally, and (0,1)-(1,1)-(2,1) vertically
    L[0][0].keys.r = true; L[0][1].keys.l = true; // horizontal link
    L[0][1].keys.d = true; L[1][1].keys.u = true; L[1][1].keys.d = true; L[2][1].keys.u = true; // vertical chain
    const gL = findMatchGroups(L, BLOCK);
    if (!(gL.length >= 1 && gL[0].cells.length >= 3)) console.warn("Test6: expected bending L‑shape match");

    // Test 7: reshuffle should NOT move or clear specials
    const withSpecial = mk([
      [A, B, C, A],
      [B, A, C, B],
      [C, B, A, C],
      [A, C, B, A],
    ]);
    withSpecial[1][1].special = "stripeH"; // lock here
    const beforeType = withSpecial[1][1].type;
    const resh = reshuffleBoard(withSpecial, 3, BLOCK);
    if (resh[1][1].special !== "stripeH" || resh[1][1].type !== beforeType) {
      console.warn("Test7: special should remain in place and unchanged during reshuffle");
    }

    // Test 8: when no swaps create matches, hint should be null
    const noMove = mk([
      [A, B, C, A],
      [B, C, A, B],
      [C, A, B, C],
      [A, B, C, A],
    ]);
    const hint = findFirstHint(noMove, BLOCK);
    if (hint !== null && !hasAnyValidMove(noMove, BLOCK)) {
      console.warn("Test8: expected null hint when no valid moves exist");
    }

    console.log("Internal tests completed");
  } catch (err) {
    console.error("Internal tests error:", err);
  }
}

// === END: your component ===

  // Mount
  (function mountGame() {
    const container = document.getElementById('root');
    if (!container) {
      console.error('Match3: root container missing');
      return;
    }
    if (ReactDOM && typeof ReactDOM.createRoot === 'function') {
      const root = ReactDOM.createRoot(container);
      root.render(React.createElement(Match3CanvasGame));
    } else if (ReactDOM && typeof ReactDOM.render === 'function') {
      ReactDOM.render(React.createElement(Match3CanvasGame), container);
    } else {
      container.innerHTML = '<div style="color:#fff;padding:24px;text-align:center">Unable to load game. Please ensure the bundled React scripts are available.</div>';
      console.error('Match3: ReactDOM is unavailable');
    }
  })();
})();
  </script>
</body>
</html>
